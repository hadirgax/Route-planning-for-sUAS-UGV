---
title: Reproduction of JINT publication
output: 
    html_document
execute:
    cache: false
---
# Init
```{python, include=F, echo=F}
import pandas as pd
import matplotlib.pyplot  as plt
import K_means_clustering_2cluster_3clustdist_bounds_one as Km
import UGV_route_2cluster_3clustdist_bounds_one as UGV
import MCsim_3veh_2cluster_3clustdist_bounds_one as MCsim
points = pd.read_excel("3veh_2clusters_3clustdist_datapts/3veh_2clusters_1bd_2.xlsx")
```

# Data presentation
```{python}
points.describe()
```
```{python}
#|fig.cap: "Plot of the data given by the authors"
points.plot.scatter("x","y")
```

Seems valid with the data presented in `3veh_2clusters_3clustdist_plots.pdf`, but only checked visually

# Making K-means points

I have to modify the `clustered_locations` in the `K_means_clustering_2cluster_3clustdist_bounds_one.py` to open the data given in the previous file.
I remove also the plotting function from the general function to allow just the computing of the centroids

```{python}
target_locations = points[["x","y"]].values
ctrd, _, labels = Km.clustered_locations(target_locations=target_locations)
```

Now I plot the centroids through the defined function of the authors
```{python}
Km.plot_centroids(points, ctrd, labels)
```

# Computing the UGV route
I modify the `main` to avoid regenerating the data and using the given data by the authors.
I remove the textual output to help understanding

```{python, echo=F}
UGV_route, mission_locations, solution = UGV.main(target_locations=target_locations)
```

The `route_location` is the same as the centroids of the K-means
I did not find any script to do the plotting of the solution of the UGV route.

```{python}
x_route = [i[0] for i in UGV_route]
y_route = [i[1] for i in UGV_route]
Km.plot_centroids(points, ctrd, labels)
plt.title("Solution for the UGV, with distance {}".format(solution.ObjectiveValue()))
plt.plot(x_route, y_route)
plt.show()
```

The figure is not very clear but the UGV starts on the red point

# Finding the drone routes

I modify the code of `MCsim_3veh_2cluster_3clustdist_bounds_one.py` to help understanding and usage of the code. Confirmed by the authors, the usage is to call the main function. By design the optimization can only be made on 25 target points, so I will keep only the 25st first points.
We plot also the figure generated by the code of the authors
```{python, echo=F}
result_list = MCsim.main(nb_exp=1, list_locations=[target_locations.tolist()[0:25]])
result_data = result_list[0][0]
result_solution = result_list[0][1]
result_routing = result_list[0][2]
```

We print below each of the UAV route independently to help with visualisation,
```{python}
def get_path_UAV(locations, routing, uav_id, solution):
    """
    return the x and y coordinates of the points visited by drone uav_id, in order of visit
    Copied and adapted from the original code
    """
    path_x = []
    path_y = []
    index = routing.Start(uav_id)
    while not routing.IsEnd(index):
        index = solution.Value(routing.NextVar(index))
        if index > 32:
            continue
        path_x.append(locations[index + (index > 7)][0])
        path_y.append(locations[index + (index > 7)][1])
    return path_x, path_y 


targets_x = [x[0] for x in result_data["locations"][9:]]
targets_y = [x[1] for x in result_data["locations"][9:]]
UGV_x = [x[0] for x in result_data["locations"][0:9]]
UGV_y = [x[0] for x in result_data["locations"][0:9]]
UAV_x, UAV_y = get_path_UAV(result_data["locations"], result_routing, 0, result_solution)
UAV_x = [result_data["locations"][0][0]] + UAV_x
UAV_y = [result_data["locations"][0][1]] + UAV_y
plt.plot(targets_x, targets_y, 'kx')
plt.plot(UGV_x, UGV_y, 'k')
plt.plot(UAV_x, UAV_y, color="red")
```
```{python}
UAV_x, UAV_y = get_path_UAV(result_data["locations"], result_routing, 1, result_solution)
UAV_x = [result_data["locations"][0][0]] + UAV_x
UAV_y = [result_data["locations"][0][1]] + UAV_y
plt.plot(targets_x, targets_y, 'kx')
plt.plot(UGV_x, UGV_y, 'k')
plt.plot(UAV_x, UAV_y, color="green")

```
```{python}
UAV_x, UAV_y = get_path_UAV(result_data["locations"], result_routing, 2, result_solution)
UAV_x = [result_data["locations"][0][0]] + UAV_x
UAV_y = [result_data["locations"][0][1]] + UAV_y
plt.plot(targets_x, targets_y, 'kx')
plt.plot(UGV_x, UGV_y, 'k')
plt.plot(UAV_x, UAV_y, color="blue")
```

We observe strange behaviours:
+ The UAV ends its route with 0 fuel but not at a meeting point with the UGV


To be sure I reproduce the clustering with only the 25 first points
```{python, echo=F}
ctrd, _, labels = Km.clustered_locations(target_locations=target_locations[0:25])
UGV_route, mission_locations, solution = UGV.main(target_locations=target_locations[0:25])
x_route = [i[0] for i in UGV_route]
y_route = [i[1] for i in UGV_route]
plt.title("Solution for the UGV, with distance {}".format(solution.ObjectiveValue()))
Km.plot_centroids(points[0:25], ctrd, labels)
plt.plot(x_route, y_route)
```
